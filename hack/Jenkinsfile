def cleanupEnv() {
    sh(label: 'Execute Python cleanup env script', script:
    'python3 -c "from hack.build_images import cleanup_env; cleanup_env(\'${OUTPUT_FILE}\')"')
}

def getLastImageCreated() {
    def lines = readFile(env.OUTPUT_FILE).readLines()
    return lines.get(lines.size()-1)
}

pipeline {
    agent {
        label 'docker-engine'
    }
    parameters {
        string(name: 'DOCKER_REGISTRY', defaultValue: "stg-artifactory.xiv.ibm.com:5030")
        string(name: 'DRIVER_GIT_BRANCH', defaultValue: "release-1.4.0")
        string(name: 'CONSOLE_GIT_BRANCH', defaultValue: "release-1.4.0")
        string(name: 'OPERATOR_GIT_BRANCH', defaultValue: "release-1.4.0")
        string(name: 'PLATFORM', defaultValue: "linux/amd64")
    }
    environment {
        registryCredentialsID = 'csi_w3_user'
        OUTPUT_FILE = 'odf-images-url.txt'
        CONSOLE_IMAGE = ''
        DRIVER_IMAGE = ''
    }
    options {
        ansiColor('xterm')
    }
    stages {
        stage ('Setup environment') {
            steps {
                sh(label: 'Install Python requirements', script: 'pip3 install GitPython && pip3 install pyYaml')
                cleanupEnv()
            }
        }
        stage ('Login to registry') {
            steps {
                withCredentials([usernamePassword(credentialsId: registryCredentialsID, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
                    sh 'docker login -u $USERNAME -p $PASSWORD ${DOCKER_REGISTRY}'
                }
            }
        }
        stage ('Driver: Build and push image') {
            steps {
                script {
                    sh(label: 'Execute Python build image script', script:
                    'python3 -c "from hack.build_images import build_and_push_driver_image; build_and_push_driver_image(\'${DOCKER_REGISTRY}\', \'${DRIVER_GIT_BRANCH}\', \'${PLATFORM}\', \'${OUTPUT_FILE}\')"')
                    env.DRIVER_IMAGE=getLastImageCreated()
                }
            }
        }
        stage ('Console: Build and push image') {
            steps {
                script {
                    sh(label: 'Execute Python build image script', script:
                    'python3 -c "from hack.build_images import build_and_push_console_image; build_and_push_console_image(\'${DOCKER_REGISTRY}\', \'${CONSOLE_GIT_BRANCH}\', \'${PLATFORM}\', \'${OUTPUT_FILE}\')"')
                    env.CONSOLE_IMAGE=getLastImageCreated()
                }
            }
        }
//         stage ('Operator: Build and push image') {
//             steps {
//                 script {
//                     sh(label: 'Execute Python Code', script:
//                     'python3 -c "from hack.build_images import build_and_push_operator_image; build_and_push_operator_image(\'${DOCKER_REGISTRY}\', \'${OPERATOR_GIT_BRANCH}\', \'${DRIVER_IMAGE}\', \'${CONSOLE_IMAGE}\', \'${PLATFORM}\', \'${OUTPUT_FILE}\')"')
//                 }
//             }
//         }
    }
    post {
        always {
            sh 'docker logout ${DOCKER_REGISTRY}'
        }
        success {
            script {
                echo "finished successfully"
                if (fileExists("${OUTPUT_FILE}")) {
                    archiveArtifacts "${OUTPUT_FILE}"
                }
            }
        }
        cleanup {
            script {
                cleanupEnv()
            }
        }
    }
}
